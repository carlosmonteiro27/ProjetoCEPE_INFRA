import tkinter as tk
from tkinter import ttk, messagebox
import math

# =============================================================================
# BACKEND (L√ìGICA DE C√ÅLCULO)
# =============================================================================
TABELA_ACO = {
    4.2: 0.109, 5.0: 0.154, 6.3: 0.245, 8.0: 0.395,
    10.0: 0.617, 12.5: 0.963, 16.0: 1.578, 20.0: 2.466, 25.0: 3.853
}

class Estaca:
    def __init__(self, nome, tipo, qtd, d_fuste_cm, l_fuste_m, l_arm_m, cobrimento_cm):
        self.nome = nome
        self.tipo = tipo 
        self.qtd = int(qtd)
        self.d_fuste = float(d_fuste_cm) / 100.0
        self.l_fuste = float(l_fuste_m)
        self.l_arm = float(l_arm_m)
        self.cobrimento = float(cobrimento_cm) / 100.0
        self.longitudinal = []
        self.transversal = None

    def add_longitudinal(self, qtd_barras, diametro_mm):
        self.longitudinal.append({'n': int(qtd_barras), 'phi': float(diametro_mm), 'gancho': 0})

    def set_transversal(self, tipo_transv, diametro_mm, espacamento_cm):
        self.transversal = {
            'tipo': tipo_transv, 'phi': float(diametro_mm), 's': float(espacamento_cm) / 100.0
        }

    @property
    def d_arm(self):
        return self.d_fuste - (2 * self.cobrimento)

def calcular_quantitativos(estaca):
    resumo_aco = {} 
    def adicionar_peso(diametro, comprimento_total_m):
        peso_linear = TABELA_ACO.get(diametro, 0)
        peso = comprimento_total_m * peso_linear * 1.10 
        resumo_aco[diametro] = resumo_aco.get(diametro, 0) + peso

    for long in estaca.longitudinal:
        l_total = long['n'] * estaca.l_arm 
        adicionar_peso(long['phi'], l_total * estaca.qtd)

    if estaca.transversal:
        phi_tr = estaca.transversal['phi']
        s = estaca.transversal['s']
        l_total_transv_unitario = 0
        if estaca.transversal['tipo'] == 'Anelar':
            perimetro = math.pi * (estaca.d_arm + phi_tr/1000.0) + 0.10
            n_estribos = math.ceil(estaca.l_arm / s) + 1
            l_total_transv_unitario = n_estribos * perimetro
        elif estaca.transversal['tipo'] == 'Helicoidal':
            perimetro_medio = math.pi * (estaca.d_arm) 
            l_passo = math.sqrt(perimetro_medio**2 + s**2)
            num_passos = estaca.l_arm / s
            l_total_transv_unitario = num_passos * l_passo
        adicionar_peso(phi_tr, l_total_transv_unitario * estaca.qtd)

    return resumo_aco

# =============================================================================
# FRONTEND (INTERFACE OTIMIZADA)
# =============================================================================
lista_estacas = []

# --- Cores e Estilo ---
COR_FUNDO = "#F0F2F5"       # Cinza muito claro (fundo moderno)
COR_HEADER = "#002F5D"      # Azul Escuro (Estilo ITA)
COR_CARD = "#FFFFFF"        # Branco para os cart√µes
COR_TEXTO = "#333333"       # Cinza escuro para texto
COR_BOTAO_ADD = "#00A859"   # Verde sucesso
COR_BOTAO_REL = "#007ACC"   # Azul a√ß√£o
COR_BOTAO_SALVAR = "#6C757D" # Cinza neutro

# --- Classe Personalizada para Caixa Arredondada (Rounded Entry) ---
class RoundedEntry(tk.Canvas):
    def __init__(self, parent, width, placeholder="", font=("Segoe UI", 10), **kwargs):
        super().__init__(parent, width=width, height=35, bg=COR_CARD, highlightthickness=0, **kwargs)
        self.command = None
        
        # Desenha o ret√¢ngulo arredondado (Visual)
        self.create_rounded_rect(2, 2, width-2, 32, radius=10, fill="#E6E6E6", outline="#CCCCCC")
        
        # Cria a entrada de texto real (Invis√≠vel esteticamente, funcional)
        self.entry = tk.Entry(self, borderwidth=0, bg="#E6E6E6", font=font, fg=COR_TEXTO)
        self.entry.place(x=10, y=7, width=width-20, height=20)
        
        if placeholder:
            self.entry.insert(0, placeholder)

    def create_rounded_rect(self, x1, y1, x2, y2, radius=25, **kwargs):
        points = [x1+radius, y1, x1+radius, y1, x2-radius, y1, x2-radius, y1, x2, y1, x2, y1+radius, x2, y1+radius, x2, y2-radius, x2, y2-radius, x2, y2, x2-radius, y2, x2-radius, y2, x1+radius, y2, x1+radius, y2, x1, y2, x1, y2-radius, x1, y2-radius, x1, y1+radius, x1, y1+radius, x1, y1]
        return self.create_polygon(points, **kwargs, smooth=True)

    def get(self):
        return self.entry.get()

    def delete(self, first, last):
        self.entry.delete(first, last)
        
    def insert(self, index, string):
        self.entry.insert(index, string)

# --- Fun√ß√µes da Interface ---
def adicionar_estaca():
    try:
        val_l_fuste = float(entry_lfuste.get())
        val_l_arm = float(entry_larm.get())

        if val_l_arm > val_l_fuste:
            messagebox.showwarning("Erro de Engenharia", 
                f"Aten√ß√£o: O Comprimento Armado ({val_l_arm}m) n√£o pode ser maior que o Fuste ({val_l_fuste}m)!")
            return 

        e = Estaca(
            entry_nome.get(), combo_tipo.get(), entry_qtd.get(),
            entry_diam.get(), str(val_l_fuste), str(val_l_arm), entry_cob.get()
        )
        e.add_longitudinal(entry_n_barras.get(), combo_bitola_long.get())
        e.set_transversal(combo_tipo_trans.get(), combo_bitola_trans.get(), entry_passo.get())
        
        lista_estacas.append(e)
        messagebox.showinfo("Sucesso", f"Estaca {e.nome} adicionada!")
        entry_nome.delete(0, tk.END)

    except ValueError:
        messagebox.showerror("Erro", "Verifique os campos num√©ricos.")

def gerar_relatorio():
    texto = "=== RELAT√ìRIO T√âCNICO ===\n\n"
    total_geral = 0
    for e in lista_estacas:
        resumo = calcular_quantitativos(e)
        texto += f"ELEMENTO: {e.nome} | TIPO: {e.tipo}\n"
        peso_local = 0
        for bitola, peso in sorted(resumo.items()):
            texto += f"  √ò {bitola:>5}mm: {peso:8.2f} kg\n"
            peso_local += peso
        texto += f"  Subtotal....: {peso_local:8.2f} kg\n"
        texto += "-"*30 + "\n"
        total_geral += peso_local
    texto += f"\nTOTAL GERAL (+10%): {total_geral:.2f} kg"
    
    text_resultado.delete(1.0, tk.END)
    text_resultado.insert(tk.END, texto)

def salvar_arquivo():
    conteudo = text_resultado.get(1.0, tk.END)
    if len(conteudo.strip()) == 0:
        messagebox.showwarning("Aviso", "Gere o relat√≥rio antes de salvar.")
        return
    with open("Relatorio_Aco_Estacas.txt", "w", encoding="utf-8") as arquivo:
        arquivo.write(conteudo)
    messagebox.showinfo("Sucesso", "Arquivo salvo!")

# --- CONFIGURA√á√ÉO DA JANELA PRINCIPAL ---
janela = tk.Tk()
janela.title("Quantitativo de Estacas - ITA/CEPE")
janela.geometry("600x750")
janela.configure(bg=COR_FUNDO)

# 1. HEADER (TOPO AZUL COM LOGOS)
frame_header = tk.Frame(janela, bg=COR_HEADER, height=100)
frame_header.pack(fill="x")

# Tentar carregar logos (precisam estar na pasta como png)
try:
    img_ita = tk.PhotoImage(file="logo_ita.png").subsample(4, 4) # Ajuste o subsample para diminuir
    lbl_ita = tk.Label(frame_header, image=img_ita, bg=COR_HEADER)
    lbl_ita.pack(side="left", padx=15, pady=10)
except:
    tk.Label(frame_header, text="[LOGO ITA]", fg="white", bg=COR_HEADER).pack(side="left", padx=15)

try:
    img_cepe = tk.PhotoImage(file="logo_cepe.png").subsample(3, 3) # Ajuste o tamanho conforme necess√°rio
    lbl_cepe = tk.Label(frame_header, image=img_cepe, bg=COR_HEADER)
    lbl_cepe.pack(side="right", padx=15, pady=10)
except:
    tk.Label(frame_header, text="[LOGO CEPE]", fg="white", bg=COR_HEADER).pack(side="right", padx=15)

tk.Label(frame_header, text="Automa√ß√£o de Quantitativos\nArmaduras de Estacas", 
         font=("Segoe UI", 16, "bold"), fg="white", bg=COR_HEADER).pack(pady=20)

# 2. √ÅREA DE CONTE√öDO
frame_main = tk.Frame(janela, bg=COR_FUNDO)
frame_main.pack(pady=10, padx=20, fill="both", expand=True)

# Fun√ß√£o auxiliar para labels
def create_label(parent, text, r, c):
    tk.Label(parent, text=text, font=("Segoe UI", 10, "bold"), bg=COR_CARD, fg="#555").grid(row=r, column=c, sticky="w", pady=(10,0), padx=5)

# --- CART√ÉO: DADOS DA ESTACA ---
lbl_titulo1 = tk.Label(frame_main, text="Dados Geom√©tricos", font=("Segoe UI", 12, "bold"), bg=COR_FUNDO, fg=COR_HEADER)
lbl_titulo1.pack(anchor="w")

frame_dados = tk.Frame(frame_main, bg=COR_CARD, bd=1, relief="solid")
frame_dados.pack(fill="x", pady=5, ipady=10)

# Linha 1
create_label(frame_dados, "Nome do Elemento:", 0, 0)
entry_nome = RoundedEntry(frame_dados, width=150)
entry_nome.grid(row=1, column=0, padx=10, pady=5)

create_label(frame_dados, "Tipo de Estaca:", 0, 1)
combo_tipo = ttk.Combobox(frame_dados, values=["Raiz", "Helice", "Escavada"], width=15, font=("Segoe UI", 11))
combo_tipo.grid(row=1, column=1, padx=10, pady=5)
combo_tipo.current(0)

create_label(frame_dados, "Quantidade:", 0, 2)
entry_qtd = RoundedEntry(frame_dados, width=80)
entry_qtd.grid(row=1, column=2, padx=10, pady=5)

# Linha 2
create_label(frame_dados, "Di√¢metro (cm):", 2, 0)
entry_diam = RoundedEntry(frame_dados, width=150)
entry_diam.grid(row=3, column=0, padx=10, pady=5)

create_label(frame_dados, "Comp. Fuste (m):", 2, 1)
entry_lfuste = RoundedEntry(frame_dados, width=120)
entry_lfuste.grid(row=3, column=1, padx=10, pady=5)

create_label(frame_dados, "Comp. Armado (m):", 2, 2)
entry_larm = RoundedEntry(frame_dados, width=120)
entry_larm.grid(row=3, column=2, padx=10, pady=5)

# Cobrimento (escondido/padr√£o visualmente mas necess√°rio)
entry_cob = tk.Entry(frame_dados) # Cria invis√≠vel s√≥ pra logica ler
entry_cob.insert(0, "3")

# --- CART√ÉO: ARMADURAS ---
lbl_titulo2 = tk.Label(frame_main, text="Detalhamento da Armadura", font=("Segoe UI", 12, "bold"), bg=COR_FUNDO, fg=COR_HEADER)
lbl_titulo2.pack(anchor="w", pady=(15,0))

frame_arm = tk.Frame(frame_main, bg=COR_CARD, bd=1, relief="solid")
frame_arm.pack(fill="x", pady=5, ipady=10)

# Linha 1 Armadura
create_label(frame_arm, "N¬∫ Barras Long.:", 0, 0)
entry_n_barras = RoundedEntry(frame_arm, width=100)
entry_n_barras.grid(row=1, column=0, padx=10)

create_label(frame_arm, "Bitola Long (mm):", 0, 1)
combo_bitola_long = ttk.Combobox(frame_arm, values=list(TABELA_ACO.keys()), width=10, font=("Segoe UI", 11))
combo_bitola_long.grid(row=1, column=1, padx=10)

# Linha 2 Estribo
create_label(frame_arm, "Tipo Estribo:", 2, 0)
combo_tipo_trans = ttk.Combobox(frame_arm, values=["Helicoidal", "Anelar"], width=15, font=("Segoe UI", 11))
combo_tipo_trans.grid(row=3, column=0, padx=10, pady=(10,5))

create_label(frame_arm, "Bitola Estribo:", 2, 1)
combo_bitola_trans = ttk.Combobox(frame_arm, values=list(TABELA_ACO.keys()), width=10, font=("Segoe UI", 11))
combo_bitola_trans.grid(row=3, column=1, padx=10, pady=(10,5))

create_label(frame_arm, "Passo (cm):", 2, 2)
entry_passo = RoundedEntry(frame_arm, width=100)
entry_passo.grid(row=3, column=2, padx=10, pady=(10,5))

# --- BOT√ïES ---
frame_botoes = tk.Frame(janela, bg=COR_FUNDO)
frame_botoes.pack(pady=10)

# Bot√µes estilizados (planos e coloridos)
btn_add = tk.Button(frame_botoes, text="‚úö Adicionar Estaca", command=adicionar_estaca, 
                    bg=COR_BOTAO_ADD, fg="white", font=("Segoe UI", 10, "bold"), relief="flat", padx=15, pady=5)
btn_add.pack(side="left", padx=5)

btn_calc = tk.Button(frame_botoes, text="‚ñ∂ Gerar Relat√≥rio", command=gerar_relatorio, 
                     bg=COR_BOTAO_REL, fg="white", font=("Segoe UI", 10, "bold"), relief="flat", padx=15, pady=5)
btn_calc.pack(side="left", padx=5)

btn_save = tk.Button(frame_botoes, text="üíæ Salvar TXT", command=salvar_arquivo, 
                     bg=COR_BOTAO_SALVAR, fg="white", font=("Segoe UI", 10, "bold"), relief="flat", padx=15, pady=5)
btn_save.pack(side="left", padx=5)

# --- RESULTADO E RODAP√â ---
text_resultado = tk.Text(janela, height=8, width=60, font=("Consolas", 9), relief="flat", bg="#FFF8DC")
text_resultado.pack(pady=5, padx=20)

lbl_creditos = tk.Label(janela, 
    text="Desenvolvido por: Asp Monteiro | Orientador: Cap Eng Edmir\nProjeto de Est√°gio 2026 - Engenharia Civil ITA", 
    bg=COR_FUNDO, fg="#888888", font=("Segoe UI", 8))
lbl_creditos.pack(side="bottom", pady=10)

janela.mainloop()
